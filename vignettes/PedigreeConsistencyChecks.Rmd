---
title: "Pedigree Consistency Checks"
author: "Sophie Kunz and Peter von Rohr"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pedigree Consistency Checks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r PackageSetup, eval=TRUE, include=FALSE, results='hide'}
#vec_pkgs <- c("pryr", "readxl","magrittr", "dplyr")
#if (!all(sapply(vec_pkgs, 
#       function(x) x  %in% installed.packages(), USE.NAMES = FALSE))){
#  for (pgk in vec_pkgs){
#    if (!pgk %in% installed.packages())
#      install.packages(pkgs = pgk)
#  }  
#}
require(pryr)
require(magrittr)
require(dplyr)
require(PedigreeFromTvdData)
```

# Consistency Checks
Besides reading the data, checking for certain consistency properties is also required in our project. So far, we have read our data into a nested list of lists which is a specialized data structure. The goal of this section is to adapt the consistency checks for the resulting data structure of one of the faster reading methods.

## Data Input
Based on our comparison of reading fwf-pedigree-data into R, we use package `LaF` to read the data and directly convert the data read into a `tbl_df`. This is done in the function `laf_open_fwf_tvd_input` of package `PedigreeFromTvdData`. 

```{r}
sDataFileName <- system.file(file.path("extdata","KLDAT_20170524_10000.txt"), 
                             package = "PedigreeFromTvdData")
vecFormat <- c(22,14,3,31,8,14,3,1,14,3)
tbl_ped <- laf_open_fwf_tvd_input(ps_input_file = sDataFileName,
                                  pvec_col_position = vecFormat)
```

Besides the time it takes to read pedigree data, we are also interested in the amount of memory it takes to store the pedigree data. We are using package `pryr` to get information about memory usage. For more information about R memory usage, we refer to [Advanced R](http://adv-r.had.co.nz/memory.html). The size in memory of the complete pedigree is

```{r}
pryr::object_size(tbl_ped)
```

The total amount of memory used by all objects is

```{r}
pryr::mem_used()
```

## Checking format of TVD-Ids
In a first consistency check, we are correcting for wrongly formatted TVD-Ids. In the test dataset that we used so far, all IDs are correctly formatted, hence the original pedigree will be the same as the corrected version after the verification.

```{r}
lIdCols <- getTvdIdCols()
system.time(tbl_ped_id_checked <- check_tvd_id_tbl(ptblPedigree = tbl_ped,
                                                   plIdCols = lIdCols))
```

The timing values indicate how long it takes to do the checks. The checks are done by giving the original pedigree as input and the checked and modified pedigree is obtained as a function result. In the modified pedigree any IDs that are recognized as incorrect are set to `NA`. In order to monitor the amount of memory used during the check, we use the function `pryr::mem_change()`. 

```{r}
pryr::mem_change(tbl_ped_id_checked <- check_tvd_id_tbl(ptblPedigree = tbl_ped,
                                                        plIdCols = lIdCols))
```

Because the change in memory is very small, we can see that the method of consistency check should not have a negative impact on the memory usage.

The consistency check for the TVD-Ids is successful, if the original pedigree and the verified pedigree after the check are the same.

```{r}
# check whether ID-columns of original and checked pedigrees are the same
all(tbl_ped_id_checked[[lIdCols$TierIdCol]] == tbl_ped[[lIdCols$TierIdCol]])
```

The simple comparison as was done with the TVD-Ids for each animal in column $6$ cannot be done for the parents, because, we cannot assume that they have the same number of `NA`s. Hence we have to find the IDs which are only `NA` in the corrected version of the pedigree.

```{r}
# checks for mothers
(l_check_result_mothers <- all_parent_id_consistent(p_tbl_ped = tbl_ped,
                                                    plIdCols  = lIdCols, 
                                                    pn_parent_col = lIdCols$MutterIdCol))
```
The same check is also done for the fathers.

```{r}
# checks for fathers
(l_check_result_fathers <- all_parent_id_consistent(p_tbl_ped = tbl_ped,
                                                    plIdCols  = lIdCols, 
                                                    pn_parent_col = lIdCols$VaterIdCol))
```


```{r, echo=FALSE, results='asis'}
if (!l_check_result_fathers$b_consistency_check){
  ### # there was a problem with sire-IDs
  cat("Some of the sire-IDs were found to have a problem with their format. Their IDs look as follows: \n\n")
  print(tbl_ped[[lIdCols$VaterIdCol]][l_check_result_fathers$vec_incons_rows[1:3]])
  cat("\nHence we are trying to re-read the pedigree using different column formats.\n")
} else {
  ### # no problems found
  cat("The format of the sire-IDs was found to be ok.\n")
}
```

```{r}
# read pedigree again with new format
tbl_ped_new <- laf_open_fwf_tvd_input(ps_input_file = sDataFileName)
# validate IDs
tbl_ped_id_checked <- check_tvd_id_tbl(ptblPedigree = tbl_ped_new)
# check parents
l_tvd_id_col_dsch <- getTvdIdColsDsch()
l_check_result_mothers <- all_parent_id_consistent(p_tbl_ped = tbl_ped_new,
                                                   plIdCols  = l_tvd_id_col_dsch, 
                                                   pn_parent_col = l_tvd_id_col_dsch$MutterIdCol)
l_check_result_fathers <- all_parent_id_consistent(p_tbl_ped = tbl_ped_new, 
                                                   plIdCols  = l_tvd_id_col_dsch,
                                                   pn_parent_col = l_tvd_id_col_dsch$VaterIdCol)
cat("The result of the check with the new pedigree is:\n")
all(tbl_ped_id_checked[[l_tvd_id_col_dsch$TierIdCol]] == tbl_ped_new[[l_tvd_id_col_dsch$TierIdCol]])
print(l_check_result_mothers)
print(l_check_result_fathers)
```

### Small example tests
In a much smaller data set, we are deliberately inserting some mistakes which should show up with our correction methd.


```{r}
sSmallDataFileName <- system.file(file.path("extdata","KLDAT_20170524_20.txt"), 
                             package = "PedigreeFromTvdData")

tbl_small_ped <- readr_fwf_tvd_input(psInputFile = sSmallDataFileName)
tbl_small_ped_checked <- check_tvd_id_tbl(ptblPedigree = tbl_small_ped,
                                          plIdCols = lIdCols)
```

The IDs with the wrong format are set to `NA`.

```{r}
(na_idx <- which(is.na(tbl_small_ped_checked[[6]]) & !is.na(tbl_small_ped[[6]])))
```

The corresponding records are:

```{r}
tbl_small_ped[c(na_idx),]
```


## Checking birthdates
Birthdates are validated using the tbd_df pedigree with the new format.

```{r}
n_bd_col_idx <- getBirthdateColIdxDsch()
### # convert birthdates from string to numeric
if (is.character(tbl_ped_id_checked[[n_bd_col_idx]])){
  tbl_ped_id_checked[[n_bd_col_idx]] <- as.integer(tbl_ped_id_checked[[n_bd_col_idx]])
}
tbl_ped_id_bd_checked <- check_birthdate_tbl(ptblPedigree = tbl_ped_id_checked,
                                             pnBirthdateColIdx = n_bd_col_idx)
(l_check_result_bd <- all_birthdate_consistent(p_tbl_ped = tbl_ped_id_checked, 
                                               pn_bd_col_idx = n_bd_col_idx))
```


## Parents must be older than offspring
Whenever parents also appear as animals, they must be older than their offspring. This translates into the integer value of the parents' birthdate must be smaller than the birthdate value of their offspring. The check is not straightforward, because the birthdate of the parents is only present whenever the parent is also available with its animal record. Hence a first goal is to obtain the birthdate of a given parent.

We start with the mothers. To find the birthdate of the mothers, we have to find those mothers which are also present as animals. We are using some `dplyr`-based functionalities to do that selection. For this task, we only need a subset of all columns of the pedigree, hence we first select the relevant columns and then give them meaningful names

```{r}
# select columns
tbl_age_check <- tbl_ped_id_bd_checked %>% select(l_tvd_id_col_dsch$TierIdCol,
                                 n_bd_col_idx,
                                 l_tvd_id_col_dsch$MutterIdCol)
# assign names
names(tbl_age_check) <- c("Animal", "Birthdate", "Mother")
# head to check
head(tbl_age_check)
```

IDs of mothers are found in the respective column, hence we filter out all those records which do not have a mother

```{r}
tbl_mother_id <- tbl_age_check %>% filter(Mother != "") %>% select(Mother)
nrow(tbl_mother_id)
head(tbl_mother_id)
```

To get to the birthdate of those mothers, we join them back to `tbl_age_check` using `dplyr`s function `inner_join` which finds for each mother its corresponding animal record.

```{r}
(tbl_mother_bd <- tbl_mother_id %>% inner_join(tbl_age_check, by = c("Mother" = "Animal"))
 %>% select(Mother,Birthdate))
nrow(tbl_mother_bd)
```

One check that the above worked can be done by looking up one records of the selected mothers in the original `tbl_df`

```{r}
tbl_ped_id_bd_checked[tbl_ped_id_bd_checked[[l_tvd_id_col_dsch$TierIdCol]] == tbl_mother_bd$Mother[1], c(1,5,11,12,16)]
```

Mother and birthdates are joined back together to their offspring records

```{r}
(tbl_mother_offspring <- tbl_mother_bd %>% inner_join(tbl_age_check, by = "Mother"))
```

Then we apply the rather arbitrarily chosen consistency criterion that the difference between the birthdates must be larger then say $10^4$ which corresponds to about one year.

```{r}
(tbl_mother_offspring %>% filter((Birthdate.y - Birthdate.x) < 10^4))
```

The same must be done for fathers. Instead of copy-paste, we construct a function that does the same validation.

```{r, eval=FALSE}
#' Check that parents are older than their offspring
#'
#' @param ptbl_pedigree pedigree in tbl_df format
#' @param pn_offspring_col column index for offspring
#' @param pn_birthday_col column index for birthdates of offspring 
#' @param pn_parent_col column index for parents
#' @param pn_date_diff_tol minimum difference between birthdates of parents and offspring
#' @return tbl_df of pedigree records not fullfilling requirements
check_parent_older_offspring <- function(ptbl_pedigree, 
                                         pn_offspring_col, 
                                         pn_birthday_col, 
                                         pn_parent_col,
                                         pn_date_diff_tol = 10^4) {

  ### # using pipes, we can link all the steps together
  tbl_age_check  <- ptbl_pedigree %>% select(pn_offspring_col,
                                            pn_birthday_col,
                                            pn_parent_col)
  ### # assign names
  names(tbl_age_check) <- c("Animal", "Birthdate", "Parent")


  ### # piping all selections, joins and filters together
  tbl_inconsistent_result <- 
    tbl_age_check %>% 
    filter(Parent != "") %>% 
    select(Parent) %>% 
    inner_join(tbl_age_check, by = c("Parent" = "Animal")) %>% 
    select(Parent,Birthdate) %>% 
    inner_join(tbl_age_check, by = "Parent") %>% 
    filter((Birthdate.y - Birthdate.x) < pn_date_diff_tol)
    
    
  return(tbl_inconsistent_result)
}
```

Testing with our pedigree again leads to the following result

```{r}
(tbl_fail_mother_age <- check_parent_older_offspring(ptbl_pedigree = tbl_ped_id_bd_checked, 
                                         pn_offspring_col = l_tvd_id_col_dsch$TierIdCol, 
                                         pn_birthday_col = n_bd_col_idx, 
                                         pn_parent_col = l_tvd_id_col_dsch$MutterIdCol))

```

Doing the same thing for father

```{r}
(tbl_fail_father_age <- check_parent_older_offspring(ptbl_pedigree = tbl_ped_id_bd_checked, 
                                         pn_offspring_col = l_tvd_id_col_dsch$TierIdCol, 
                                         pn_birthday_col = n_bd_col_idx, 
                                         pn_parent_col = l_tvd_id_col_dsch$VaterIdCol))

```

Again checking that first record of the above result, if any result was found, leads to the following

```{r}
if (nrow(tbl_fail_father_age) > 0){
  tbl_ped_id_bd_checked[tbl_ped_id_bd_checked[[l_tvd_id_col_dsch$TierIdCol]] == tbl_fail_father_age$Animal[1], c(1,5,11,12,16)]
} else {
  cat("No inconsistencies with age of fathers found\n")
}
```


## One for all
Reading the pedigree and doing all checks is combined in the function `build_check_pedigree_from_tvd()` which just needs the file with the TVD-Data as input.

```{r}
tbl_ped_final <- build_check_pedigree_from_tvd(ps_tvd_file = sDataFileName)
```

The following checks wether the result of the single checks is the same as the result after the overall checks.

```{r}
all.equal(tbl_ped_final, tbl_ped_id_bd_checked)
```


# Resources
- R memory usage in [Advanced R](http://adv-r.had.co.nz/memory.html)


# Session Info
```{r}
sessionInfo()
```


# Latest Update
`r paste(Sys.time(),paste0("(", Sys.info()[["user"]],")" ))`

